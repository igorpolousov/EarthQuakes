#  EarthQuake Apple tutorials

Что вообще хочется от этого проекта - почерпнуть что-то новое и полезное))

   Данное приложение представлено компанией Apple как инструкция. Будет сделана копия приложения шаг за шагом, чтобы понять что на данный момент предлагает сделать Apple. Затем, по примеру этого приложения, будет сделан рефакторинг простейшего приложения Заметки.
   
   Построено с использованием SwitUI. 
   
   ## Что сразу хочется отметить: в файлах с кодом сделаны комментарии к коду, двойной // или тройной /// косой чертой. На мой взгляд комментарии с /// тройной косой чертой дают более быстрый способ понять зачем сделана переменная(константа) или объект. Без использования Jump to Defenition. Show quick help inspector - более удобный вариант. Apple использует для своих базовых классов, протоколов, структур именно комментарии с /// косой чертой и достаточно подробно расписывает назначение. Попробую делать так же, в конце будет возможность оценить этот подход.
    ( по ходу добавления кода будет дополняться)
   
    Для начала проекта пользователю предлагается стартовый и законченный проекты.  Рекомендуется скачать стартовый проект и уже в нем сделать изменения в файлах и добавить файлы. 

  Я буду делать проект с нуля. Первым шагом буду создавать и добавлять  все файлы и код из стартового проекта. 
  Вторым шагом буду делать проект по шагам из инструкции. 

Разработчики компании Apple  формируют код следующим образом: Пишется основная структура данных, а все протоколы для структуры или протоколы и наследованная для классов пишутся отдельно ниже в коде или даже в отдельном файле

## Файлы в приложении разбиты по их назначению в группы: Models, Views, Resources.

## Как делать лучше naming файлов? Так как делает Apple - положили в папку с соответсвующим названием и достаточно или лучше в каждом файле в названии указывать что это model или view??

##Папка Models стартового проекта содержит: 
Два файла:
Quake.swift  - содержит структуру Quake в которой представлены свойства по землетрясению - representing quake data
Quake+Color.swift - содержит расширение к структуре Quake с цветами

## Папка Views стартового проекта содержит:
Три файла, содержащие SwiftUI Structures с протоколом View, так что при создании файлов будем использовать New file from Template->SwiftUI View и папку ToolbarContent, в которой 6 фалов для создания ToolbarView и его элементов: 

## Разработчики максимально разбили интерфейс на отдельные элементы и разложили из по разным файлам и расширениям  чтобы такое простое приложение можно было просто читать. Очень интересно аналогичным способом сделать в UIKit в коде  - есть ли, как говорится "выхлоп" в этом SwiftUI с его View in Structs, opaque types, view builder, wrapper и прочим - или это маркетинг чтобы поддержать акции Apple - вот мы делаем какой-то новый продукт? 

## 9 файлов для таблицы и четырёх кнопок))

Quakes.swift - Main screen view + extension with computed properties and functions
QuakeRow.swift -  View for row in  Quakes List view
QuakeMagnitude.swift - View for QuakeRow

ToolbarContent folder:
Quakes+Toolbar.swift - extension for Quakes with ToolBarBuilder
SelectButton.swift -  Enum Select mode button + Select Button View
EditButton.swift - View
RefreshButton.swift - View
ToobarStatus.swift - View
DeleteButton.swift - View

Вот вроде и всё что было в стартовом проекте. 
Первое впечатление такое: что большое количество связанности в проекте - в любом из 8 фалов не будет работать и главный экран не запустится. View и обработка действий пользователя распололжены в одних и тех же местах.

 ## Section 1: Decode Earthquake data 
USGS предоставляет данные в специальном JSON формате - GeoJSON.  Пример GeoJSON  информации включает в себя:
Точку на карте
Пограничная зона обслуживания сотовой связи или целый горный хребет( не понятно для начала что имелось ввиду)

Каждый GeoJSON предоставляет данные по одной точке , данные будут декодированы и превращены в Swift Structure

Функция GeoJSON отличается от структуры Swift Quake в  приложении Earthquakes. Она включает в себя свойства, которые не используются в Earthquakes. А некоторые свойства GeoJSON имеют имена и типы, которые не соответствуют структуре модели вашего приложения. Вам нужно будет управлять декодированием данных GeoJSON в структуры Swift, настраивая процесс десериализации.

В этом разделе вы будете использовать протокол Decodable для десериализации отдельного объекта GeoJSON. Вы будете декодировать некоторые, но не все свойства объекта. Кроме того, вы сможете устранить несоответствия свойств, настроив способ декодирования объекта Earthquakes в экземпляре Quake.

Список дальнейших шагов:
1. В Quake.swift делаем расширение для структуры Quake чтобы она соотвествовала протоколу Decodable. Поскольку в этом проекте будет только декодирование JSON вместо протокола Codable будет использован этот протокол.
2. Добавляем private enum CodingKeys со String raw values. GeoJSON хранит свои свойства и значения в виде списка пар ключ-значение. Это перечисление представляет собой пользовательский список имен, которые сопоставляют ключи GeoJSON со свойствами Quake.
3. Меняем string raw value для magnitude, Поскольку было добавлено необработанное значение в enum case, ваше приложение может прочитать свойство JSON, имя которого не соответствует структуре вашей модели Swift
4. Добавляем инициализатор, который принимает Decoder. Это позволит кастомизировать процесс декодирования
5. Добавляем Container, который будет содержать значения для CodingKeys 
## В Xcode 16.1 значения были добавлены автоматически, хотя немного отличались от предложенных в обучающем материале. Попробуем использовать оба варианта  
6. Добавляем декодирование всех свойств
7. Поскольку в инструкции были предложены опциональные значения try?(может есть может нет), то ниже был предложен вариант unwrap optionals при помощи guard. Xcode 16.1 предложил значения без опционала.

Поскольку значения опциональные и некоторые могут не существовать, то 8 шагом предлагается сделать:
8. QuakeError.swift - file с QuakeError enum и соотвествием протоколу Error
9. Добавляем расширение для QuakeError с протоколом LocalizedError чтобы получать описание ошибки
10. Завершаем инициализатор при помощи добавления соотвествующих значений 

Структура для декодирования готова, леоаем cmd + B для проверки на ошибки и в следующей секции будем делать тест структуры для декодирования GeoJSON.

## Section 2: Test the decoder
