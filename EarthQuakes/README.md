#  EarthQuake Apple tutorials Copyright © 2025 Apple Inc. All rights reserved.

Что вообще хочется от этого проекта - почерпнуть что-то новое и полезное))

   Данное приложение представлено компанией Apple как инструкция. Будет сделана копия приложения шаг за шагом, чтобы понять что на данный момент предлагает сделать Apple. Затем, по примеру этого приложения, будет сделан рефакторинг простейшего приложения Заметки.
   
   Построено с использованием SwitUI. 
   
   ## Что сразу хочется отметить: в файлах с кодом сделаны комментарии к коду, двойной // или тройной /// косой чертой. На мой взгляд комментарии с /// тройной косой чертой дают более быстрый способ понять зачем сделана переменная(константа) или объект. Без использования Jump to Defenition. Show quick help inspector - более удобный вариант. Apple использует для своих базовых классов, протоколов, структур именно комментарии с /// косой чертой и достаточно подробно расписывает назначение. Попробую делать так же, в конце будет возможность оценить этот подход.
    ( по ходу добавления кода будет дополняться)
   
    Для начала проекта пользователю предлагается стартовый и законченный проекты.  Рекомендуется скачать стартовый проект и уже в нем сделать изменения в файлах и добавить файлы. 

  Я буду делать проект с нуля. Первым шагом буду создавать и добавлять  все файлы и код из стартового проекта. 
  Вторым шагом буду делать проект по шагам из инструкции. 

Разработчики компании Apple  формируют код следующим образом: Пишется основная структура данных, а все протоколы для структуры или протоколы и наследованная для классов пишутся отдельно ниже в коде или даже в отдельном файле

## Файлы в приложении разбиты по их назначению в группы: Models, Views, Resources.

## Как делать лучше naming файлов? Так как делает Apple - положили в папку с соответсвующим названием и достаточно или лучше в каждом файле в названии указывать что это model или view??

##Папка Models стартового проекта содержит: 
Два файла:
Quake.swift  - содержит структуру Quake в которой представлены свойства по землетрясению - representing quake data
Quake+Color.swift - содержит расширение к структуре Quake с цветами

## Папка Views стартового проекта содержит:
Три файла, содержащие SwiftUI Structures с протоколом View, так что при создании файлов будем использовать New file from Template->SwiftUI View и папку ToolbarContent, в которой 6 фалов для создания ToolbarView и его элементов: 

## Разработчики максимально разбили интерфейс на отдельные элементы и разложили из по разным файлам и расширениям  чтобы такое простое приложение можно было просто читать. Очень интересно аналогичным способом сделать в UIKit в коде  - есть ли, как говорится "выхлоп" в этом SwiftUI с его View in Structs, opaque types, view builder, wrapper и прочим - или это маркетинг чтобы поддержать акции Apple - вот мы делаем какой-то новый продукт? 

## 9 файлов для таблицы и четырёх кнопок))

Quakes.swift - Main screen view + extension with computed properties and functions
QuakeRow.swift -  View for row in  Quakes List view
QuakeMagnitude.swift - View for QuakeRow

ToolbarContent folder:
Quakes+Toolbar.swift - extension for Quakes with ToolBarBuilder
SelectButton.swift -  Enum Select mode button + Select Button View
EditButton.swift - View
RefreshButton.swift - View
ToobarStatus.swift - View
DeleteButton.swift - View

Вот вроде и всё что было в стартовом проекте. 
Первое впечатление такое: что большое количество связанности в проекте - в любом из 8 фалов не будет работать и главный экран не запустится. View и обработка действий пользователя распололжены в одних и тех же местах.

 ## Section 1: Decode Earthquake data 
USGS предоставляет данные в специальном JSON формате - GeoJSON.  Пример GeoJSON  информации включает в себя:
Точку на карте
Пограничная зона обслуживания сотовой связи или целый горный хребет( не понятно для начала что имелось ввиду)

Каждый GeoJSON предоставляет данные по одной точке , данные будут декодированы и превращены в Swift Structure

Функция GeoJSON отличается от структуры Swift Quake в  приложении Earthquakes. Она включает в себя свойства, которые не используются в Earthquakes. А некоторые свойства GeoJSON имеют имена и типы, которые не соответствуют структуре модели вашего приложения. Вам нужно будет управлять декодированием данных GeoJSON в структуры Swift, настраивая процесс десериализации.

В этом разделе вы будете использовать протокол Decodable для десериализации отдельного объекта GeoJSON. Вы будете декодировать некоторые, но не все свойства объекта. Кроме того, вы сможете устранить несоответствия свойств, настроив способ декодирования объекта Earthquakes в экземпляре Quake.

Список дальнейших шагов:
1. В Quake.swift делаем расширение для структуры Quake чтобы она соотвествовала протоколу Decodable. Поскольку в этом проекте будет только декодирование JSON вместо протокола Codable будет использован этот протокол.
2. Добавляем private enum CodingKeys со String raw values. GeoJSON хранит свои свойства и значения в виде списка пар ключ-значение. Это перечисление представляет собой пользовательский список имен, которые сопоставляют ключи GeoJSON со свойствами Quake.
3. Меняем string raw value для magnitude, Поскольку было добавлено необработанное значение в enum case, ваше приложение может прочитать свойство JSON, имя которого не соответствует структуре вашей модели Swift
4. Добавляем инициализатор, который принимает Decoder. Это позволит кастомизировать процесс декодирования
5. Добавляем Container, который будет содержать значения для CodingKeys 
## В Xcode 16.1 значения были добавлены автоматически, хотя немного отличались от предложенных в обучающем материале. Попробуем использовать оба варианта  
6. Добавляем декодирование всех свойств
7. Поскольку в инструкции были предложены опциональные значения try?(может есть может нет), то ниже был предложен вариант unwrap optionals при помощи guard. Xcode 16.1 предложил значения без опционала.

Поскольку значения опциональные и некоторые могут не существовать, то 8 шагом предлагается сделать:
8. QuakeError.swift - file с QuakeError enum и соотвествием протоколу Error
9. Добавляем расширение для QuakeError с протоколом LocalizedError чтобы получать описание ошибки
10. Завершаем инициализатор при помощи добавления соотвествующих значений 

Структура для декодирования готова, леоаем cmd + B для проверки на ошибки и в следующей секции будем делать тест структуры для декодирования GeoJSON.

## Section 2: Test the decoder

Test case выполняет часть кода контролируемым образом. Если результат теста отличается от ожидаемого, Test case завершается ошибкой. В этом разделе будут добавлены тесты и примеры тестовых данных, чтобы убедиться, что приложение надежно расшифровывает GeoJSON. Эти тесты подтверждают, что Quake structure обладает правильными свойствами после того, как будет произведена расшифровка.

Xcode использует targets для поддержки отдельных сред сборки. Вы начнете с добавления нового targeta тестирования в свой проект, чтобы создать среду тестирования. Затем вы будете использовать платформу XCTest framework для создания и запуска модульных тестов.

Список шагов этой секции:
1. Выберите File > New > Target и выберите Unit testing bundle, чтобы добавить новый target модульного тестирования в Earthquakes.

Интересно: Target добавляет template files, settings и build rules, которые отделены от приложения, но позволяют получить доступ к интерфейсу приложения.

При разработке и тестировании первой части приложения будет использованы примеры данных в формате GeoJSON вместо получения данных по сети.

2. Control-click the EarthquakesTests group в Project navigator, и добавте новый файл TestData.swift к этой группе.

3. В File navigator, необходимо проверить Target Membership секцию, aи убедиться что файл TestData.swift  в списке EarthquakesTests target.

4. Создайте константу данных, закодировав строковый литерал в формате GeoJSON.
Синтаксис тройных кавычек позволяет создавать многострочные строковые литералы. Тип значения Data позволяет буферу байт в памяти вести себя как Foundation object.
5. Скопировать данные GeoJSON в константу из файла в стартовом проекте

6. В файле EarthQuakesTest.swift удалить все функции, которые были созданы Xcode по умолчанию.

7. Создаём test case с названием testGeoJSONDecoderDecodesQuake и сделать throw для обработки ошибок
  
  В названии методов тест кейсов необходимо использовать уникальные имена точно описывающие тестируемый функционал
8. Пишем код для декодирования GeoJSON данных и делаем AssertEqual для проверки полученных данных
функция decode() может выбрасывать ошибку, в этом случает тест будет провален
9. Запускаем тест и проверяем работу. Тест пройден.
10. Создаём константы для сравнения ожидаемого времени из выборочных данных с расшифрованным временем землетрясения.
11. Добавляем следующий Assert для проверки получаемой величины quake.time

tip: Выберите Product > Test или нажмите Command-U, чтобы выполнить все тесты в вашем проекте. Слева от каждого теста Xcode отображает результаты в виде зеленой отметки об успешном выполнении или красного крестика в случае неудачи.

12. Запустили тест и видим что тест не пройден, По умолчанию JSON-декодер декодирует время в секундах, а ожидаемые результаты - в миллисекундах.
13. Обновлем декодер, чтобы он декодировал время в миллисекундах
14. Запускаем все тесты через тест навигатор
15. Предлагается самостоятельно добавить еще один компонент в структуру Quake - это tsunami. добавим и сделаем тест.  Для свойства tsunami передается тип данных Int со значениями: 1 - для океанической местности и 0 - для всех остальных типов местности. Само значение не гворит о вероятности цунами, а лишь указывает в случае с кодом 1 на то что будет ссылка на данные о цунами. Так как в нашем тестовом образце занчение tsunami == 0, будем проверять в тестах правильность декодирования и сравнивать quake.tsunami сщ значением 0.

  Периодическое выполнение тестов — особенно после добавления новых функций — гарантирует, что ваш код будет продолжать работать так, как вы ожидаете.

## Section 3: Decode GeoJSON
 В этой секции будет расшифрована вся иерархия GeoJSON через структуру Quake. Будет сделан доступ к массиву объектов GeoJSON и будет использована модель Quake для декодирования каждого объекта GeoJSON.
 
 Первоначальный объект GeoJSON содержит 4 ключа: type, metadata, features, bbox. Значение по ключу features - это массив объектов GeoJSON. Каждый объект под ключём features содержит 4 ключа: type, properties, geometry, id. Значения под ключём properties содержит данные, которые будут декодироваться в объект Quake.  

GeoJSON - это структурированные данные, поэтому каждый ключ может содержать одно значение, массив значений или другие дочерние объекты. Некоторые значения, которые вы будут использованы Earthquakes, находятся в объектах, вложенных в другие объекты. В Swift вложенный контейнер представляет собой свойство JSON, значение которого содержит массив или дочерний объект.
Контейнер может быть как с ключом, так и без ключа. В предыдущей секции расшифровали объект GeoJSON, в котором каждый ключ содержит одно значение. Был использован контейнер с ключом и указаны пять уникальных кодирующих ключей — mag, place, time, code и detail — для доступа к их значениям.
Можно декодировать неназванные элементы JSON, такие как массивы, с помощью контейнера без ключа. В корневом объекте GeoJSON значением ключа features является массив объектов. Для доступа к этому массиву объектов будем использовать контейнер без ключа.

1. В папке Models создаём файл GeoJSON.swift, в этом файле создадим структуру GeoJSON, которая содержит массив объектов Quake
2. Создаем coding key для начального объекта GeoJSON

## Забыли делать комментарии для кода который уже написали))

3. Создаём coding key для объекта features
4. Создаём инициализатор в котором будем получать контейнер начального объекта GeoJSON, так же может выбрасывать ошибку, помечаем throws для обработки ошибки
5. В инициализаторе создаем переменную для получения объекта features
6. Сделаем цикл while для получения объектов Quake до тех пор, пока флаг isAtEnd не станет равным true, и будем декодировать каждый элемент как Quake. В случае успеха будем добавлять quake в массив quakes.
7. Добавим к struct GeoJSON протокол Decodable
8. Добавим в файл TestData.swift данные для тестирования декодирования объекта GeoJSON с использованием struc GeoJSON. Эти данные представляют собой 6 объектов GeoJSON с шестью ключами feature и с шестью объектами properties
9. В EarthQuakes.swift добавим тестовую фунцию чтобы проверить работу  struct GeoJSON. В итоге должно быть получено 6 объектов Quake и протестируем данные которые приходят в объект Quake.
10. В test navigator запускаем все тесты и проверяем что все пройдены

## Section 4: Декодирование местоположения 

   Каждый объект Quake содержит своство detail. Это свойство является отдельным GeoJSON объектом, который содержить долготу и широту.
   Информация о местоположении находится внутри стурктуры, inside deeply nested structure. Чтобы декодировать информацию о местоположении, будем создавть swift структры.
   
   1. В папке Models создадим файл QuakeLoction.swift с одноименной структурой
   2. Добавим свойства долготы и широты с типом данных Double. Изначально данные представлены в фармате String, но нам удобнее использовать Double, поэтому будет сделана конвертация.
   3. Добавим Decodable протокол к QuakeLocation и создадим структуры для доступа к location
   4. Сделаем расширение для OriginProperties для получения данных долготы и широты с типом данных строка и далее сконвертируем в тип Double
   5. Сделаем свойсва latitude и longitude структуры QuakeLocation вычисляемыми чтобы при создании объекта были известны их значения

## Section 5: Тестирование объекта QuakeLocation

   Протестируем и убедимся, что приложение корректно декодирует данные GeoJSON
   1. Добавим в файл TestData.swift пример данных для декодирования местоположения
   2. В файле EarthquakesTests.swift добавим новый метод для тестирования 
   3. Запустим выполнение тестов
   
# UI и Models сделаны. Будем делать Network client
## Section 1: Создание network client для получения данных с удаленного сервера
   Apple предлагает не создавать сразу сервис, с делать протокол, который будет определять необходимые свойства для API. Для тестирования будет использоваться "заглушка" или по другому mock data
   
   1. Создадим файл с названием HTTPDataDownloader.swift и внутри создадим протокол с одноименным названием и функцией получения данных по ссылке
   2. Создадим extension для URLSEssion и применим протокол 
   3. Для реализации получения данных будет использован метод data(from:delegate:) из URLSession
   4. Создаём новый файл QuakeClient.swift и создадим внутри одноименный class 
   5. Создадим свойство feedURL которое будет содержать ссылку для скачивания данных
   6. Создадим свойство decoder  стипом данных JSONDecoder
   7. Сделаем свойство downloader и сделаем к нему инициализатор с default value
   ## интересный момент: обратить внимание как сделано вычисляемое свойство для хранения объектов quake
cmd+b - проверяем на ошибки и клиент готов.

## Section 2: Тестирование QuakeClient
   1. Переместим TestData.swift в папку PreviewContent, это позволит сделать доступным данные из этого фалйа как для unit tests, так и для SwiftUI previews.
   2. Создаём новый файл TestDownloader.swift в папке PreviewContent и создаем TestDownloader class и подпишем его на протокол 
   3. Добавим Task.sleep(nanoseconds:) в метод httpData(from: URL) для симуляции задержки передачи данных по сети. Возвращать будет testQuakesData
   4. В EarthQuakesTest.swift добавляем новый тест метод testClientDoesFetchEarthQuakeData()
   5. Создаем экземпляр класса TestDownloader и используем его при создании QuakeClient
   6. Получим quakes из клиента и проверим что количество сущностей равно 6
   7. Запустим тест
   
 ## Section 3: Получение и использование данных от QuakeClient  
    Для синхронизации данных между view и коллекцией, в SwiftUI используется ObservableObject, в этой главе создадим такой объект и будем использовать его для получения данных в Quake структурах.
    1. Создаём новый файл QuakesProvider и подписываем его под протокол ObservableObject и для массива со структурами Quake добавим @Published property wrapper
    2. Добавим свойство QuakeClient и добавим для него init
    3. Создадим функцию fetchQuakes которая будет получать данные из клиента client:QuakeClient и будет обновлять данные в массиве quakes
    4. Добавим функцию для удаления Quake из массива. Функция будет принимать аргумет offSets: IndexSet чтобы её можно было использовать с модификатором delete(perform:) в List view
    5. Добавим в файл EarthQuakesApp.swift @StateObject и environment object, таким образом у нас будет глобальная переменная для работы с её данными в SwiftUI уже после запуска приложения
    6. В файле Quakes.swift в структуре Quakes заменим свойство quakes на @EnviironmentOobject var provider: QuakesProvider
    
    После 6 шага компилятор выдаст ошибки и нужно сделать исправления во всех местах кода, где они появились. 
    
    7. Добавим await  и сделаем функцию fetchQuakes() с асинхронным вызовом
    8. Добавим do-catch block чтобы сделать обработку ошибки throws
    9. Заменим все ссылки на убранную переменную quakes на данные из provider
    10. В файле Quakes+toolbar.swift будем использовать provider и async fetchquakes()
    
    После замены во всех местах получение данных из quakes на provide проект будет компилироваться без ошибок.
    
    11. В файле Quakes.swift добавим модификатор .task для NavigationView
    12. Сдалаем добавление в preview 
    13. Запустим preview в файле Quakes.swift и проверим корректность отображения и возможность удаления Quake
    
 ## Section 4: Test concurrent data access (Тестирование параллельного доступа к данным).

    Вступление к жтой секции такое, что Swift имеет очень простой синтаксис для написания кода для параллельного выполнения, но нужно не забывать Shit happens. Например что будет происходить если две задачи будут одновременно брать данные(иметь доступ) к QuakeProvider?  
    
    Фреймворки Apple для создания UI требуют, чтобы вся действия, связанные с UI выполнялись в главном потоке. Поэтому предлагается сделать так чтобы все действия с массивом quakes в QuakeProvider выполнялись в главном потоке. Потому что этот массив на прямую влияет на данные в UI приложения. В Apple есть сочетание функций языка Swift и инструментов Xcode, которые помогают выявлять и устранять подобные проблемы. В этом разделе будет использовано средство проверки потоков среды выполнения Xcode для обнаружения небезопасного доступа из фонового потока. Затем решим проблему с помощью языковых функций Swift, которые гарантируют, что функции QuakesProvider будут выполняться в основном потоке.
     1. Чтобы запустить данный иснтрумент делаем следующие шаги в верхнем меню: Product -> Scheme -> EditScheme, в появимшемся окне слева выбираем пункт меню Run - справа вверху  выбираем Diagnostics, Ставим галочку напротив Main Thread checker
     2. Делаем запуск приложения и смотрим появятся ли предупреждения. Если будет небезопасный доступ к потоку - будет выдано предупреждение. По идее должно появиться, потому что QuakesProvider для получения  значений для массива quakes использует асинхронную функцию fetchQuakes(), которая может вызываться в разных потоках.
     3. Чтобы убрать предупреждение и сделать доступ к методам QuakesProvider только в главном потоке используем атрибут @MainActor  для всего класса. Применение данного атрибута переведет выполнение всех методов класса только в главный поток.
     4. Build and run -> no warnings - Запустим приложение и видим, что предупреждение исчезло.
     
     Посмотрите еще раз как сделано get async throws свойство var quakes в файле QuakeClient
     
     ## Управление структурированной многопоточностью
     Приложение EarthQuake получает данные из сети асинхронно. Далее в приложении будут сделаны дополнительные сетевые запросы чтобы получить детали каждого землетрясения, точнее будет сделано изменение для клиента QuakeClient чтобы он мог делать множественные сетевые запросы.
     
     ### Получение данных с нескольких URL адресов( Fetching data from multiple URLs)
     Это приложение делает один сетевой запрос для того чтобы получить список землетрясений. Далее в этом приложении будут сделаны изменения которые позволят делать множественные сетевые запросы одновременно! Очень интересно!
     
     QuakeCkient использует асинхронные функции и свойства чтобы отложить выполнение кода пока приложение выполняет сетвой зпрос. Пример ниже ожидает выполнения асихронного кода чтобы возвратить список землетрясений.
     
     let quakes: [Quake] = try await quakeClient.quakes
     
     Далее нам нужно получить детали для каждого землетрясения. Каждая struct Quake содержит свойство detail которое содержит URL. 
     Допустим у нас есть метод, который может получить quake location для каждого землетрясения
  
     func quakeLocation(from url: URL) -> QuakeLocation
     
     и мы хотим сделать вызов этого метода параллельно и таким образом чтобы система могла сделать множественные одновременные сетевые запросы. Рассмотрим следующий пример: 
     
        let quakes: [Quake] = try await quakeClient.quakes
        var locations: [QuakeLocation] = []
        for quake in quakes {
            let location = await quakeClient.quakeLocation(from: quake.url)
            locations.append(locations)
        } 

    Этот код является асинхронным, но все же последовательным. Система откладывает выполнение следующей итерации в цикле. Когда выполнена одно итерация(сетевой запрос) система переходит к выполению следующей итерации цикла, а нм нужен способ чтобы выполнять не только асинхронно, но и многопоточно.
    
    Решением является task group выполнять несколько задач параллельно. Система будет выполнять задачи в параллельных потоках. Чтобы создать task group нужно воспользоваться функцией withTaskGroup() или withThrowingTaskGroup(). Поскольку мы используем throwing , то нужно будет пользоваться withThrowingTaskGroup()
    Функция принимает аргумент с типом данных task result и замыкание и передаёт task group в замыкание. Очень понятно))
    В примере ниже, группа  - это значение throwingTaskGroup. Внутри замыкания добавляются задания в группу и происходит ожидание, пока они не выполнятся.
    
        
            let quakes: [Quake] = ... // Get an array of quakes.
            try await withThrowingTaskGroup(of: QuakeLocation.self) { group in
                var locations: [QuakeLocation] = []
                for quake in quakes {
                    group.addTask {
                        // Work inside this closure is captured as a task.
                        // The code should return a QuakeLocation.
                        return try await quakeClient.quakeLocation(from: quake.url)
                    }
                }
                // Wait on a result with group.next().
                while let location = try await group.next() {
                    // The constant location is a QuakeLocation.
                    locations.append(location)
                }
            }
    Task Group добавляет многопоточность в приложение, но многопоточность может привнести вариации(разные варианты) выполнения кода в  приложнеии. Когда инициируются множественные многопоточные сетевые запросы, то отсутсвует контроль в каком порядке будут приходить ответы на запросы. Чтобы понять как это происходит, код выше можно запустить несколько раз(с идентичным вводом данных) и увидеть, что элементы массива locations будут приходить в разном порядке. Swift предлагает использовать actor чтобы избавится от такой непредсказуемости.
    
    ### Protecting data with actors/ Защита данных при помощи actor
    
    После внесения изменений в клиент, чтобы делать многопоточные запросы, будут сделаны изменения в клиенте, чтобы полявилась возможность делать cache данных quake location, для этого будет использоваться NSCache class, чтобы зарнить данные о локациях.
    Наличие доступа к сущности класса из множественных параллельных задач может привести к проблеме под названием Data Races.
    
    Для примера, допустим что кэширования запросов, делается их подсчёт при помощи класса Counter class:
    
        class Counter {
        var count: Int = 0


        func increment() {
            count = count + 1
            }
        } 

    Если добваить этот класс в код с task group, код будет выглядеть так и assert будуе периодически выдавать ошибку
        
        try await withThrowingTaskGroup(of: QuakeLocation.self) { group in
        let count = Counter() // Create a counter object.
        var locations: [QuakeLocation] = []
        for quake in quakes {
            group.addTask {
                let location = try await provider.location(for: quake.url)
                // Increment the counter after fetch completes.
                count.increment() 
            }
        }
        while let location = try await group.next() {
            locations.append(location)
        }
        // This will sometimes fail.
        assert(counter.count == locations.count) 
    }
    
    Этот пример вызывает increment() из множественных параллельно выполняемых задач, может получиться так, что однвременно будут выполнены 2 задачи, и счётчик увеличит значение только один раз, и один из запросов не будет учтён(посчитан).
    Можно исправить такой вопрос если добавить счётчик в вызов group.next()
    Другим вариантом решения данной задачи является использование Swift Actor. Swift Actor позволяет управлять многопоточным доступом к сущности, делая таким образом, чтобы только один поток мог обратиться к сущности в один прмежуток времени. Таким образом имеем , что Actor это thread safe Class data type, который позволяет решить проблему Data Race. Поменяем class Counter на actor Counter 

        actor Counter {
        var count: Int = 0


        func increment() {
            count = count + 1
        }
    }

    ##Компилятор Swift обеспечивает безопасность actor, ограничивая доступ к методам и свойствам actor.
    Свойство counter является неизменяемым в коде, определенном вне субъекта счетчика, даже если оно объявлено как var. Если вы попытаетесь изменить свойство count вне субъекта счетчика, компилятор выдаст сообщение об ошибке. Вы можете косвенно изменить свойство с помощью методов, определенных внутри counter, таких как increment(). 
    ###Поскольку метод increment изменяет состояние actor, вы должны использовать ключевое слово await при вызове increment() извне actor.

    let counter = Counter() // Counter is an actor.
    counter.count = 0 // Error: Can't mutate property.
    let currentCount = counter.count // Error: Can't synchronously access property.
    let currentCount = await counter.count // Asynchronous access to the property is allowed.
    counter.increment() // Error: Can't synchronously call method.
    await counter.increment() // Asynchronous access to the method is allowed.
    
    Требуя асинхронного доступа к внутренним данным, исполнитель может обеспечить одновременный доступ к свойству только для одной задачи
    
    Являюсь классом и нахожусь в heap, но имею повадки struct из stack)) Смесь бульдога с носорогом, еще слышал что делают вручную class thread safe путём создания вручную потока и дальнейшее выполение методов класса будет производиться только в этом потоке в одно и тоже время.
    
    # Cashing network data/ Кэширование сетевых данных
    
    NSCashe - mutable collection используется для временного хранения пары ключ-значение, которую можно очистить в случае недостатка ресурсов. 
    ## Section 1: Fetch Quake location
    Каждый объект Quake USGS имеет свойство dеtails со значение URL. URL предоставляет дополнительную информацию для каждого Quake, включая местоположение Quake. В этой секции будет добавлен код для получения Quake location. 
    Приложение будет кэшировать данные о местоположении в экземплярах NSCashe. Каждая запись в кэше будет содержать одно из двух значений:
    - Quake location structure
    - Задачу(Task) который загружает Quake location structure
    Далее будут использованы Task(Задачи) из кэша, таким образом будем избегать повторных сетевых запросов.
    
    Swift enum - лучший способ сделать модель записи в кэш. NSCashe спроектировано , чтобы хранить ссылочные типы данных (reference type), но swift enum является value type.Сделаем class чтобы хранить enum и вставим экземпляр этого класса в кэш.
    
    1. Создаём новый файл CashEntryObject.swift в который добавим enum CashEntry. inProgress будет использоваться для того, чтобы предотвратить повторное начало загрузки location, когда оно уже передано в загрузку, но еще не загружено.
    2. Создадим класс для хранения enum, потому что NSCashe может хранить только ссылочные типы данных
    3. Создадим новый файл NSCashe+Subscript.swift в котором сделаем расширение для NSCashe
    4. Ограничим это расширение принимало только два типа данных
    5. Создадим subscript который будет принимать URL и возвращать CashEntry
    6. Добавляем в subscript getter который будет извлекать из NSCash CashEntryObject и возвращать CashEntry
    7. Добавляем setter чтобы сохранять CashEntryObject
    8. Если новое значение значение не уществует nil - удалить object из кэша
    9. Добавляем в QuakeClient свойство quakeCashe

    ## Section 2: Cashing quake details Кэширование информации о землетрясениях
    NSCashe - thread safe - потокобезопасная коллекция - это значит, что при доступе с множества потоков не будет data race и данные будут корректными
    Но для того чтобы гарантировать, что для каждого землетрясения данные были закачаны только один раз, просто потокобезопастности недостаточно
    
    Распространенной проблемой, связанной с многопоточным кодом, является непредсказуемый порядок выполнения. Например, рассмотрим шаги на рисунке справа, которые представляют операции, выполняемые не по порядку, характерные для многопоточных приложений. Два цвета обозначают два разных потока. Когда первый поток (выделен желтым) ожидает доступа к сети, выполнение нового метода (выделено красным) начинается до завершения предыдущего доступа к сети. Этот второй поток не должен инициировать другую выборку по сети. Вместо этого он должен дождаться уже выполненной выборки.
    ### До конца не понятно имелось ввиду в абзаце ниже, если NSCashe и так thread safe как actor еще может чем-то помочь???
В этом разделе вы будете использовать тип actor для защиты кэша. Этот actor обеспечивает сериализацию доступа, но при этом возникает одна потенциальная проблема. Когда вы вызываете await, как это делается при получении сетевых данных, выполнение приостанавливается, и исполнитель может начать выполнение новых вызовов функций до завершения сетевого вызова. Вы решите эту проблему, убедившись, что в кэше есть значение, прежде чем ожидать сетевой запрос. Второй поток найдет кэшированное значение, когда начнет выполнение, избегая дополнительного сетевого запроса.

    В текущем исполнении QuakeClient может выполнять одновременно несколько сетевых запросов по одной и той же ссылке. Добавим код, при помощи которого уберем этот вопрос
  
    1. Добавим функцию quakeLocation(from:) в файл QuakeClient, которая будет получать и декодировать значение
    2. Сделаем QuakeClient - actor type
    
    Хотя quakeCache определен как константа, внутреннее состояние объекта кэша, на который он ссылается, может изменяться. Использование QuakeClient в качестве субъекта защищает кэш от одновременного доступа из нескольких потоков.
    3. Создадим Task для получения данных о локации. Создание переменной task позволит в будущем созранить значение и проверить статус загрузки, task будет сохранена в cashe
    4. Сохраним задачу в кэше и дождемся результата
    5. Сохраним окончательно загруженную quakeLocation в кэше и вернем её
    6. Добавляем do catch 
    7. В начале метода quakeLocation(from:) добавим проверку на значения находящиеся в кэше
    8. Оператором Switch пройдем по значениям cashed

## Section 3: Fetch multiple location
    В эnтом разделе будет добавлен код реализующий многочисленные загрузки данных о землетрясении одновременно. Будет делаться запрос на землетрясения за последний час. Так как количество землетрясений в течении часа будет каждый раз разным при каждом запуске приложения будет использоваться task group для динамического добавления операций. Далее будем ожидать выполения операций и делать update соотвествующих экземплфров структур Quake, когда клиент вернёт массив quakes свойство местоположения будет заполнено для самых последних структур.
    
    1. В файле Quake.swift добавим свойство quake location optional
    2. В QuakeClient добавим локальную переменную
    3. Получим индекс элемента с временной меткой более часа назад
    4. Создаим диапазон индексов, которые покажут землетрясения за последний час
    5. Создаём task group
    6. Пройдёмся по индексам и сделаем таск на загрузку данных по каждому землетрясению
    7. Дождемся выполения каждого задания в группе, метод nextResult() возвращает Result<(Int, QuakeLocation), Error>
    8. Сделаем перебор всех результатов и добавим новые данные для землетрясений
    
## Section 1: Добавим Detail view
    1. В папке PreviewContent создадим файл Quake+Preview.swift и расширим quake model чтобы добавить статическую вычисляемую переменную
    2. В паке Views добавим файл QaukeDetail.swift
    3. Добавим quake к DetailView
    4. Добавим text label чтобы отображать широту и долготу землетрясения, если эта информация доступна.
    после добавления лэйблов ничего не отобразилось в превью на экране, потому что в файле Quake_Preview.swift нет данных о локации
    5. Добавляем данные о локации в файл Quake_Preview.swift
    6. Так же необходимо добавить инициализатор чтобы QuakeLocation отображал занчения в формате Double при создании экземпляра
    После этого на preview должны отображаться долгота и широта
    7. Применим модификатор, чтобы в значениях широты и долготы отображалось только 3 знака после запятой
    8. Добавим view в котором будет отображаться магнитуда землетрясения
    9. Для QuakesRow в файле quakes добавим navigation link для перехода на соотвествующую страницу с детализацией землетрясения
    
    experiment: добавить к тексту на DetailView жест, чтобы пользователь мог посмотреть полную или сокращенную версию широты и долготы
    1. Добавляем булевую переменную со значением по умолчанию true - чтобы менять текст 
    2. Добавляем vstack для лейблов 
    3. К Vstack добавляем onTapGesture и перключатель булевой переменной 
    и далее есть два способа: будет меняться значение в тексте(используем тернарный оператор) или будет меняться полностью view, во втором варианте нужно добавить такой же vstack с onTapGesture.
    
## Section 2: Display location details - fetch data from internet
    1. Добавим @EnvironmentObject quakes provider в Detail view, чтобы данные были доступны в этом view сарзу после запуска приложения
    2. Добавим свойство @State для хранения возможного экземпляра location
