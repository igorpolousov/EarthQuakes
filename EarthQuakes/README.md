#  EarthQuake Apple tutorials

Что вообще хочется от этого проекта - почерпнуть что-то новое и полезное))

   Данное приложение представлено компанией Apple как инструкция. Будет сделана копия приложения шаг за шагом, чтобы понять что на данный момент предлагает сделать Apple. Затем, по примеру этого приложения, будет сделан рефакторинг простейшего приложения Заметки.
   
   Построено с использованием SwitUI. 
   
   ## Что сразу хочется отметить: в файлах с кодом сделаны комментарии к коду, двойной // или тройной /// косой чертой. На мой взгляд комментарии с /// тройной косой чертой дают более быстрый способ понять зачем сделана переменная(константа) или объект. Без использования Jump to Defenition. Show quick help inspector - более удобный вариант. Apple использует для своих базовых классов, протоколов, структур именно комментарии с /// косой чертой и достаточно подробно расписывает назначение. Попробую делать так же, в конце будет возможность оценить этот подход.
    ( по ходу добавления кода будет дополняться)
   
    Для начала проекта пользователю предлагается стартовый и законченный проекты.  Рекомендуется скачать стартовый проект и уже в нем сделать изменения в файлах и добавить файлы. 

  Я буду делать проект с нуля. Первым шагом буду создавать и добавлять  все файлы и код из стартового проекта. 
  Вторым шагом буду делать проект по шагам из инструкции. 

Разработчики компании Apple  формируют код следующим образом: Пишется основная структура данных, а все протоколы для структуры или протоколы и наследованная для классов пишутся отдельно ниже в коде или даже в отдельном файле

## Файлы в приложении разбиты по их назначению в группы: Models, Views, Resources.

## Как делать лучше naming файлов? Так как делает Apple - положили в папку с соответсвующим названием и достаточно или лучше в каждом файле в названии указывать что это model или view??

##Папка Models стартового проекта содержит: 
Два файла:
Quake.swift  - содержит структуру Quake в которой представлены свойства по землетрясению - representing quake data
Quake+Color.swift - содержит расширение к структуре Quake с цветами

## Папка Views стартового проекта содержит:
Три файла, содержащие SwiftUI Structures с протоколом View, так что при создании файлов будем использовать New file from Template->SwiftUI View и папку ToolbarContent, в которой 6 фалов для создания ToolbarView и его элементов: 

## Разработчики максимально разбили интерфейс на отдельные элементы и разложили из по разным файлам и расширениям  чтобы такое простое приложение можно было просто читать. Очень интересно аналогичным способом сделать в UIKit в коде  - есть ли, как говорится "выхлоп" в этом SwiftUI с его View in Structs, opaque types, view builder, wrapper и прочим - или это маркетинг чтобы поддержать акции Apple - вот мы делаем какой-то новый продукт? 

## 9 файлов для таблицы и четырёх кнопок))

Quakes.swift - Main screen view + extension with computed properties and functions
QuakeRow.swift -  View for row in  Quakes List view
QuakeMagnitude.swift - View for QuakeRow

ToolbarContent folder:
Quakes+Toolbar.swift - extension for Quakes with ToolBarBuilder
SelectButton.swift -  Enum Select mode button + Select Button View
EditButton.swift - View
RefreshButton.swift - View
ToobarStatus.swift - View
DeleteButton.swift - View

Вот вроде и всё что было в стартовом проекте. 
Первое впечатление такое: что большое количество связанности в проекте - в любом из 8 фалов не будет работать и главный экран не запустится. View и обработка действий пользователя распололжены в одних и тех же местах.

 ## Section 1: Decode Earthquake data 
USGS предоставляет данные в специальном JSON формате - GeoJSON.  Пример GeoJSON  информации включает в себя:
Точку на карте
Пограничная зона обслуживания сотовой связи или целый горный хребет( не понятно для начала что имелось ввиду)

Каждый GeoJSON предоставляет данные по одной точке , данные будут декодированы и превращены в Swift Structure

Функция GeoJSON отличается от структуры Swift Quake в  приложении Earthquakes. Она включает в себя свойства, которые не используются в Earthquakes. А некоторые свойства GeoJSON имеют имена и типы, которые не соответствуют структуре модели вашего приложения. Вам нужно будет управлять декодированием данных GeoJSON в структуры Swift, настраивая процесс десериализации.

В этом разделе вы будете использовать протокол Decodable для десериализации отдельного объекта GeoJSON. Вы будете декодировать некоторые, но не все свойства объекта. Кроме того, вы сможете устранить несоответствия свойств, настроив способ декодирования объекта Earthquakes в экземпляре Quake.

Список дальнейших шагов:
1. В Quake.swift делаем расширение для структуры Quake чтобы она соотвествовала протоколу Decodable. Поскольку в этом проекте будет только декодирование JSON вместо протокола Codable будет использован этот протокол.
2. Добавляем private enum CodingKeys со String raw values. GeoJSON хранит свои свойства и значения в виде списка пар ключ-значение. Это перечисление представляет собой пользовательский список имен, которые сопоставляют ключи GeoJSON со свойствами Quake.
3. Меняем string raw value для magnitude, Поскольку было добавлено необработанное значение в enum case, ваше приложение может прочитать свойство JSON, имя которого не соответствует структуре вашей модели Swift
4. Добавляем инициализатор, который принимает Decoder. Это позволит кастомизировать процесс декодирования
5. Добавляем Container, который будет содержать значения для CodingKeys 
## В Xcode 16.1 значения были добавлены автоматически, хотя немного отличались от предложенных в обучающем материале. Попробуем использовать оба варианта  
6. Добавляем декодирование всех свойств
7. Поскольку в инструкции были предложены опциональные значения try?(может есть может нет), то ниже был предложен вариант unwrap optionals при помощи guard. Xcode 16.1 предложил значения без опционала.

Поскольку значения опциональные и некоторые могут не существовать, то 8 шагом предлагается сделать:
8. QuakeError.swift - file с QuakeError enum и соотвествием протоколу Error
9. Добавляем расширение для QuakeError с протоколом LocalizedError чтобы получать описание ошибки
10. Завершаем инициализатор при помощи добавления соотвествующих значений 

Структура для декодирования готова, леоаем cmd + B для проверки на ошибки и в следующей секции будем делать тест структуры для декодирования GeoJSON.

## Section 2: Test the decoder

Test case выполняет часть кода контролируемым образом. Если результат теста отличается от ожидаемого, Test case завершается ошибкой. В этом разделе будут добавлены тесты и примеры тестовых данных, чтобы убедиться, что приложение надежно расшифровывает GeoJSON. Эти тесты подтверждают, что Quake structure обладает правильными свойствами после того, как будет произведена расшифровка.

Xcode использует targets для поддержки отдельных сред сборки. Вы начнете с добавления нового targeta тестирования в свой проект, чтобы создать среду тестирования. Затем вы будете использовать платформу XCTest framework для создания и запуска модульных тестов.

Список шагов этой секции:
1. Выберите File > New > Target и выберите Unit testing bundle, чтобы добавить новый target модульного тестирования в Earthquakes.

Интересно: Target добавляет template files, settings и build rules, которые отделены от приложения, но позволяют получить доступ к интерфейсу приложения.

При разработке и тестировании первой части приложения будет использованы примеры данных в формате GeoJSON вместо получения данных по сети.

2. Control-click the EarthquakesTests group в Project navigator, и добавте новый файл TestData.swift к этой группе.

3. В File navigator, необходимо проверить Target Membership секцию, aи убедиться что файл TestData.swift  в списке EarthquakesTests target.

4. Создайте константу данных, закодировав строковый литерал в формате GeoJSON.
Синтаксис тройных кавычек позволяет создавать многострочные строковые литералы. Тип значения Data позволяет буферу байт в памяти вести себя как Foundation object.
5. Скопировать данные GeoJSON в константу из файла в стартовом проекте

6. В файле EarthQuakesTest.swift удалить все функции, которые были созданы Xcode по умолчанию.

7. Создаём test case с названием testGeoJSONDecoderDecodesQuake и сделать throw для обработки ошибок
  
  В названии методов тест кейсов необходимо использовать уникальные имена точно описывающие тестируемый функционал
8. Пишем код для декодирования GeoJSON данных и делаем AssertEqual для проверки полученных данных
функция decode() может выбрасывать ошибку, в этом случает тест будет провален
9. Запускаем тест и проверяем работу. Тест пройден.
10. Создаём константы для сравнения ожидаемого времени из выборочных данных с расшифрованным временем землетрясения.
11. Добавляем следующий Assert для проверки получаемой величины quake.time

tip: Выберите Product > Test или нажмите Command-U, чтобы выполнить все тесты в вашем проекте. Слева от каждого теста Xcode отображает результаты в виде зеленой отметки об успешном выполнении или красного крестика в случае неудачи.

12. Запустили тест и видим что тест не пройден, По умолчанию JSON-декодер декодирует время в секундах, а ожидаемые результаты - в миллисекундах.
13. Обновлем декодер, чтобы он декодировал время в миллисекундах
14. Запускаем все тесты через тест навигатор
15. Предлагается самостоятельно добавить еще один компонент в структуру Quake - это tsunami. добавим и сделаем тест.  Для свойства tsunami передается тип данных Int со значениями: 1 - для океанической местности и 0 - для всех остальных типов местности. Само значение не гворит о вероятности цунами, а лишь указывает в случае с кодом 1 на то что будет ссылка на данные о цунами. Так как в нашем тестовом образце занчение tsunami == 0, будем проверять в тестах правильность декодирования и сравнивать quake.tsunami сщ значением 0.

  Периодическое выполнение тестов — особенно после добавления новых функций — гарантирует, что ваш код будет продолжать работать так, как вы ожидаете.

## Section 3: Decode GeoJSON
 В этой секции будет расшифрована вся иерархия GeoJSON через структуру Quake. Будет сделан доступ к массиву объектов GeoJSON и будет использована модель Quake для декодирования каждого объекта GeoJSON.
 
 Первоначальный объект GeoJSON содержит 4 ключа: type, metadata, features, bbox. Значение по ключу features - это массив объектов GeoJSON. Каждый объект под ключём features содержит 4 ключа: type, properties, geometry, id. Значения под ключём properties содержит данные, которые будут декодироваться в объект Quake.  

GeoJSON - это структурированные данные, поэтому каждый ключ может содержать одно значение, массив значений или другие дочерние объекты. Некоторые значения, которые вы будут использованы Earthquakes, находятся в объектах, вложенных в другие объекты. В Swift вложенный контейнер представляет собой свойство JSON, значение которого содержит массив или дочерний объект.
Контейнер может быть как с ключом, так и без ключа. В предыдущей секции расшифровали объект GeoJSON, в котором каждый ключ содержит одно значение. Был использован контейнер с ключом и указаны пять уникальных кодирующих ключей — mag, place, time, code и detail — для доступа к их значениям.
Можно декодировать неназванные элементы JSON, такие как массивы, с помощью контейнера без ключа. В корневом объекте GeoJSON значением ключа features является массив объектов. Для доступа к этому массиву объектов будем использовать контейнер без ключа.

1. В папке Models создаём файл GeoJSON.swift, в этом файле создадим структуру GeoJSON, которая содержит массив объектов Quake
2. Создаем coding key для начального объекта GeoJSON

## Забыли делать комментарии для кода который уже написали))

3. Создаём coding key для объекта features
4. Создаём инициализатор в котором будем получать контейнер начального объекта GeoJSON, так же может выбрасывать ошибку, помечаем throws для обработки ошибки
5. В инициализаторе создаем переменную для получения объекта features
6. Сделаем цикл while для получения объектов Quake до тех пор, пока флаг isAtEnd не станет равным true, и будем декодировать каждый элемент как Quake. В случае успеха будем добавлять quake в массив quakes.
7. Добавим к struct GeoJSON протокол Decodable
8. Добавим в файл TestData.swift данные для тестирования декодирования объекта GeoJSON с использованием struc GeoJSON. Эти данные представляют собой 6 объектов GeoJSON с шестью ключами feature и с шестью объектами properties
9. В EarthQuakes.swift добавим тестовую фунцию чтобы проверить работу  struct GeoJSON. В итоге должно быть получено 6 объектов Quake и протестируем данные которые приходят в объект Quake.
10. В test navigator запускаем все тесты и проверяем что все пройдены

## Section 4: Декодирование местоположения 

   Каждый объект Quake содержит своство detail. Это свойство является отдельным GeoJSON объектом, который содержить долготу и широту.
   Информация о местоположении находится внутри стурктуры, inside deeply nested structure. Чтобы декодировать информацию о местоположении, будем создавть swift структры.
   
   1. В папке Models создадим файл QuakeLoction.swift с одноименной структурой
   2. Добавим свойства долготы и широты с типом данных Double. Изначально данные представлены в фармате String, но нам удобнее использовать Double, поэтому будет сделана конвертация.
   3. Добавим Decodable протокол к QuakeLocation и создадим структуры для доступа к location
   4. Сделаем расширение для OriginProperties для получения данных долготы и широты с типом данных строка и далее сконвертируем в тип Double
   5. Сделаем свойсва latitude и longitude структуры QuakeLocation вычисляемыми чтобы при создании объекта были известны их значения

## Section 5: Тестирование объекта QuakeLocation

   Протестируем и убедимся, что приложение корректно декодирует данные GeoJSON
   1. Добавим в файл TestData.swift пример данных для декодирования местоположения
   2. В файле EarthquakesTests.swift добавим новый метод для тестирования 
   3. Запустим выполнение тестов
   
# UI и Models сделаны. Будем делать Network client
## Section 1: Создание network client для получения данных с удаленного сервера
   Apple предлагает не создавать сразу сервис, с делать протокол, который будет определять необходимые свойства для API. Для тестирования будет использоваться "заглушка" или по другому mock data
   
   1. Создадим файл с названием HTTPDataDownloader.swift и внутри создадим протокол с одноименным названием и функцией получения данных по ссылке
   2. Создадим extension для URLSEssion и применим протокол 
   3. Для реализации получения данных будет использован метод data(from:delegate:) из URLSession
   4. Создаём новый файл QuakeClient.swift и создадим внутри одноименный class 
   5. Создадим свойство feedURL которое будет содержать ссылку для скачивания данных
   6. Создадим свойство decoder  стипом данных JSONDecoder
   7. Сделаем свойство downloader и сделаем к нему инициализатор с default value
   ## интересный момент: обратить внимание как сделано вычисляемое свойство для хранения объектов quake
cmd+b - проверяем на ошибки и клиент готов.

## Section 2: Тестирование QuakeClient
   1. Переместим TestData.swift в папку PreviewContent, это позволит сделать доступным данные из этого фалйа как для unit tests, так и для SwiftUI previews.
   2. Создаём новый файл TestDownloader.swift в папке PreviewContent и создаем TestDownloader class и подпишем его на протокол 
   3. Добавим Task.sleep(nanoseconds:) в метод httpData(from: URL) для симуляции задержки передачи данных по сети. Возвращать будет testQuakesData
   4. В EarthQuakesTest.swift добавляем новый тест метод testClientDoesFetchEarthQuakeData()
   5. Создаем экземпляр класса TestDownloader и используем его при создании QuakeClient
   6. Получим quakes из клиента и проверим что количество сущностей равно 6
   7. Запустим тест
   
 ## Section 3: Получение и использование данных от QuakeClient  
    Для синхронизации данных между view и коллекцией, в SwiftUI используется ObservableObject, в этой главе создадим такой объект и будем использовать его для получения данных в Quake структурах.
    1. Создаём новый файл QuakesProvider и подписываем его под протокол ObservableObject и для массива со структурами Quake добавим @Published property wrapper
    2.
